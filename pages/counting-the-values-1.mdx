# 计算值（Part 1）

在这个模块中，我们将更加细致的观察 `JavaScript` 世界和里面的值（value）。
但是在进行这件事情之前我们需要先处理一件更为麻烦的事情。*`JavaScript` 世界是真的存在的吗？*

## JavaScript 计算

我居住在 `JavaScript` 宇宙中的属于自己的小行星上。

当我向 `JavaScript` 宇宙询问一个问题，它会以一个值的形式回到我。我当然不能靠自己得到这些值。
变量、电线以及这些值 -- 它们填充了我的世界。我周围的 `JavaScript` 世界对我来说绝对真实，就像
你所生活的世界对你一样。

但是有时候，在下一行代码前会有片刻的沉默，下一个方法调用前会有空闲的滴答，矩阵中的失误。
在这些时刻，我看见了一个比自己的还有大得多的世界。

![视野](image/dream-glitch-optim.gif)

出现在我面前的世界，这里没有变量和值，也没有表达式和文字。取而代之的是夸克、原子、电子、水
以及生活。大概，你更加熟悉这样的世界吧。

感觉像是这里有一个叫做“人类”的生物使用着名为“电脑”的特殊的机器来计算*我*的 `JavaScript` 宇宙中的属于自己的小行星上。
他们中的一部分人是为了消遣，一部分人是为了盈利，还有一部分人没有任何理由。由于它们的心血来潮，我的整个世界每天都经历了
上兆次的出生和死亡。

*毕竟，我的 `JavaScript` 世界并没有那么真实*

这意味着有两种方法去学习。

## 从外部开始

一种学习我的 `JavaScript` 世界的方法是*从外部开始学习*

也许，你会关注于我的世界的模拟器 -- 一个 `JavaScript` 引擎是如何 “真正” 的开始工作的。
例如，你可能会了解到，这个文本的字符串 -- *我的世界的一个值* -- 是以字节序列的形式存储于
硅芯片上的。

这个方法是为了将我们的精神关注在有人类的电脑的物理世界中，一些其他的教程也运用了这种方法，但是
我的方法不一样。

## 从内部开始

我们将要*从内部开始*学习  `JavaScript`, 把你的精神传输到 `JavaScript` 宇宙和我站在一起。
我们将观察到这里的规则并且进行实验，就像是物理学家在物理宇宙中所做的那样。

**我们将会了解到 `JavaScript` 的本质是什么 -- 不需要思考它是怎么实现的。这就类似于物理学家能够讨论星体的属而不需要回答物理世界是否是真实的这样的问题。因为这并不重要，我们依旧能使用自己的术语来描述它**

我们的心智模型不会回答诸如 “值在计算机的内存中如何表示？”。因为答案一直在改变。
实际上，在你的[程序运行](https://v8.dev/blog/react-cliff?ck_subscriber_id=745643025)的时候这个问题的答案一直在变化。
如果你听到过一些关于在 `JavaScript` 中如何 “真正” 在内存中表示数字、字符串或者的对象的简单的解释的话，这些言论很有可能是错误的。

对我来说，每一个字符串都是一个值。不是 “指针” 或者 “内存地址” -- 而是一个值。
**在我的宇宙中，一个值就已经足够了。**
不要让 “存储单元” 和其他的低级隐喻分散了你构建 `JavaScript` 准确高级心智模型的注意力。
反正下面全是乌龟。（原文是  [_It’s turtles all the way down anyway!_](https://en.wikipedia.org/wiki/Turtles_all_the_way_down)）

如果你之前了解过其他的低级语言，请暂时搁置诸如 “通过引用传递”、“在堆栈上分配”、“写时复制”等等直觉。
这些计算如何运行的模型会让理解 `JavaScript` 程序能做什么和不能做什么变得**困难**。
我们会关心某些低级语言的细节，但是仅仅是[真正有用的时候](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/?ck_subscriber_id=745643025)。
这些仅仅是我们心智模型的 _添头_，而不是基础。

**与之相对的，我们心智模型的基础是我们的世界充满了值。**
每个值都属于某些内置类型。它们中的一部分是原始的，这使得这些类型的值是不可变的。
变量是连接我们代码中名字和值的线。我们将继续在这个基础上发展。

对于这些奇异的景象，我已经不再多想了。我有需要指向的线、有需要询问的问题和需要调用的方法。
我最好的到它！

星星在我注视它的时候特别的明亮。

那在我眨眼的是否它们是否还存在呢？

我耸了耸肩。

_"实施细节"_

![ream-glitch-meta-optim](/image/dream-glitch-meta-optim.gif)

## 计算值

[Count von Count](https://www.youtube.com/watch?v=eSukMy8DyfY)是我儿时的榜样。
如果你不熟悉芝麻街中的他，那我说一下他最爱的消遣便是计算事情。今天，Count von Count 将要加入我们计算 `JavaScript` 宇宙中的每个值。

你也许会想：_计算_ 值的重点是什么？我们并不是在一个算数班，是吧？计算的本质是区分事物。
只有当你清楚地看到它们是两个 _不同_ 的苹果时，你才能说有 “两个苹果”。
区分值是理解 `JavaScript` 中相等性的关键 -- 这将是我们的下一个主题。

就像维吉尔引导但丁穿越地狱的九个圈子一样，Count von Count 将陪伴我们穿越 `JavaScript` 的 “天球”，遇见不同的值：Booleans、Numbers、Strings 以及其他。将其视为观光旅游。

![celestialspheres-v2.png](/image/celestialspheres-v2.png)

### Undefined

我们将和 `Undefined` 类型一起开始我们的旅途。Count von Count 会很高兴知道**这个类型唯一的值 -- `undefined`。**

```javascript
console.log(typeof(undefined)); // "undefined"
```

![undefined-revised.png](/image/undefined-revised.png)

它叫做未定义（undefined）所以你可能会认为它是不存在的 -- 但是它确实是一个值，真实存在的。
像一个黑洞，`undefined` 脾气暴躁，经常会带来麻烦。例如，从它这里读取一个属性将会破坏你的程序：

```javascript
let person = undefined;
console.log(person.mood); // TypeError!
```

不过幸运的是，在整个 `JavaScript` 宇宙中仅有一个 `undefined`。你也许会想：它为什么会存在呢？
在 `JavaScript` 中，它代表了 _无意_ 缺失值的概念。

你可以以写成 `undefined` 的形式在你的代码中使用它 -- 就像是写 2 或者 “hello” 一样。
然而， `undefined` _也_ 会经常自然发生。它出现在 JavaScript 不知道你想要什么值的情况下。
例如，如果你忘记了定义一个变量，那它会被指定为 `undefined`。

```javascript
let bandersnatch;
console.log(bandersnatch); // undefined
```

![undefined-example.png](/image/undefined-example.png)

然后你就可以将其指定为其他的值，或者你想的话再次指定为 `undefined` 也可以。

不要被它的名字所迷惑了。这很容易将 `undefined` 视为某种变量状态，例如，“这个变量尚未定义”。
但是这是一种完全误导性的思考方式！实际上，如果你访问一个没有被定义的变量（或者在 `let` 生命之前），你将会得到一个错误：

```javascript
console.log(jabberwocky); // ReferenceError!
let jabberwocky;
```

这与 `undefined` 没有关系。

真实情况是， `undefined` 是一个普通的原始值，就像是 2 或者 “hello”。

### Null

![null-revised.png](/image/null-revised.png)

你可以将 `null` 视为 `undefined` 的姐妹。它们的行为非常相似。
例如：当你尝试访问其属性时会表现惊慌失措。

```javascript
let mimsy = null;
console.log(mimsy.mood); // TypeError!
```

![null-example.png](/image/null-example.png)

和 `undefined` 相似的是，**null 是这个类型的唯一的值。** 然而，null 也是一个骗子。
由于 JavaScript 的一个 [bug](https://2ality.com/2013/10/typeof-null.html?ck_subscriber_id=745643025)，它伪装成了一个对象。

```javascript
console.log(typeof(null)); // "object" (a lie!)
```

你也许会认为这意味着 null 是一个对象。不要陷入这个陷阱！
它是一个原始值，并且它的行为一点也不像一个对象。
不幸的是，由于历史原因我们不得不一直忍受下去。

在实践中，null 用于故意缺失值。为什么同时具有 null 和 undefined ？
这可以帮助你区分编码错误（可能导致 `undefined`）和有效的数据缺失（可能表示为 `null`）。
然而，这只是一个约定，JavaScript 并不强制这种用法。有些人会尽量避开它们两个。

我不责怪它们。

### Booleans
![boolean-revised.png](/image/boolean-revised.png)

就像是白天和黑夜，**这里也只有两个 `boolean` 类型的值：`true` 和 `false`。**

```javascript
console.log(typeof(true)); // "boolean"
console.log(typeof(false)); // "boolean"
```

我们可以可以对它们进行逻辑操作：

```javascript
let isSad = true;
let isHappy = !isSad; // 取反
let isFeeling = isSad || isHappy; // 至少有一个是 true ?
let isConfusing = isSad && isHappy; // 都是 true ?
```

Count von Count 想要检查你的心智模型。打开一个[草图 APP](https://excalidraw.com/?ck_subscriber_id=745643025) 或者拿出一张纸，画出上面代码中变量、值和它们之间的线。

_以下是剧透_
_在你画完之前不要滚动下去_

...
...
...
...
...
...
...
...
...
...

对照这张图检查你的答案：

![boolean-example](/image/boolean-example.png)

首先，验证 isHappy 指向 false，isFeeling 指向 true，isConfusing 指向 false。
（如果你的答案不一样，那一定是某个地方出现了错误 -- 一步一步检查每一行）

紧接着，验证草图上**只有一个真值和一个假值**。 Count von Count 坚持认为这很重要！
不管布尔值在内存中如何存储，在我们的心智模型中就只有这两个。

### Numbers

![numbers-v2](/image/numbers-v2.png)

到目前为止，我们准确计算了了 4 个值：null，undefined，true，和 false。

等等，我们的心智模型将增加十八亿，四百三十七亿，七百三十六万亿，八千七十四亿，四亿五千四百万，八十二万，六百二十四及更多。

当然，我的意思是数字：

```javascript
console.log(typeof(28)); // "number"
console.log(typeof(3.14)); // "number"
console.log(typeof(-140)); // "number"
```

首先，数字可能看起来不起眼。让我们仔细看看。

#### 计算机数学

JavaScript 中的数字的行为表现和常规数学的数字不一样。这是一个演示片段：

```javascript
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2 === 0.30000000000000004); // true
```

这个看起来很令人惊讶！与流行的看法相反，这并不意味值 JavaScript 中的数字是被破坏的。
这种行为在不同的编程语言中都很常见。它甚至还有一个名字：浮点数学。

你看， JavaScript 没有实现我们在现实生活中使用的那种数学。浮点数是“计算机数学”。
不用太担心这个名字或者它是如何工作的。很少有人能知道所有的细节，这才是管家吗。
它在实践中运行得很好，大多数时候你不用考虑它。不过，我们还是快速看一下是什么让它与众不同。

#### 颜色和数字

你是否曾经使用扫描仪将物理照片或者文档转换为数字照片？这个类比可以帮助我们理解 JavaScript 数字。

扫描仪通常最多可以分辨 1600 万种颜色。如果你用红色蜡笔画一张图片并扫描它，那么扫描出来的颜色应该是红色的 -- 但它会是我们的
扫描仪从这 1600 万种颜色中挑选出来的最接近的后果色。因此，如果你有两种略有不同的红色蜡笔，扫描仪可能会误认为它们是一样的颜色。

_我们可以说扫描仪将颜色是为具有有限的精度。_

浮点数是类似的。在真正的数学中，有一组无限的数字。但是在浮点数学中，只有 18 千亿 个。
所以，当我们在代码中写入数字或者使用它们进行计算时，JavaScript 会选择他所知道的最为接近的
数字 -- 就像我们的扫描仪处理颜色一样。

_换句话说，JavaScript 将数字是为有限的精度。_

我们可以想象一个轴上所有的 JavaScript 数字。我们越接近 0，数字的精度越高，它们的位置也就越近。

![number_axis](/image/number_axis.gif)

当我们从 0 向任一方向移动时，我们开始失去精度。在某些时候，即使是两个最接近的 JavaScript 数字也比 1 相距更远。

```javascript
console.log(Number.MAX_SAFE_INTEGER);     // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER + 1); // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 2); // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 3); // 9007199254740994
console.log(Number.MAX_SAFE_INTEGER + 4); // 9007199254740996
console.log(Number.MAX_SAFE_INTEGER + 5); // 9007199254740996
```

幸运的是，任何在 `Number.MIN_SAFE_INTEGER` 和 `Number.MAX_SAFE_INTEGER` 之间的**整数**都是准确的。
这就是为什么 `10 + 20 === 30`。

但是当我们写 `0.1` 或者 `0.2` 时，我们不会获取准确的 `0.1` 或者 `0.2`。我们会获取在 JavaScript 中最接近的有效数字。
它们几乎完全相同，但时可能存在细微差别。这些微小的差异会叠加，这就是为什么 `0.1 + 0.2` 和我们写的 `0.3` 不相等。

如果这仍然令人困惑，请不要担心。你可以了解有关浮点数学的更多信息，但你已经比我开始编写这本指南时了解得更多了!
除非你使用财务应用程序，否则你可能不需要担心这一点。

#### 特殊数字

值得注意的是，浮点数学中包含一些特殊数字。你可能偶尔遇到过 `NaN`、`Infinity`、`-Infinity` 和 `0`。
它们的存在是因为有时候你可能执行了诸如 `1 / 0` 这样的操作，JavaScript 需要以某种形式表示其结果。
浮点数学标准指定了它们的工作方式以及使用它们时会发生什么。

以下是代码中可能出现的特殊数字：

```javascript
let scale = 0;
let a = 1 / scale; // Infinity
let b = 0 / scale; // NaN
let c = -a; // -Infinity
let d = 1 / c; // -0
```

在这些特殊数字中， NaN 特别有趣，它表示 “不是一个数字”，是 `0 / 0` 和其他一些无效数学的结果。

你也许会对它被解释为一个数字感到困惑：

```javascript
console.log(typeof(NaN)); // "number"
```

但是，这里没有诡辩。从 JavaScript 的角度来看，NaN 是一个数值。他不是 null、undefined、string 或者其他类型。
但在浮点数学中，该属于的名称是 “不是一个数字”。所以它是一个数值，只是恰好被称为 “不是一个数字”，以为他表示无效的结果。

使用这些特殊数字编码并不常见。但是，它们可能因为编码错误而出现。所以知道它们的存在也是有必要的。

## 继续

这个模块分为两部分。我们已经到了第一部分的结尾。现在我们将稍作休息。让我们回顾一下到目前为止我们计算了多少个值！

![primitives-pt1-v3](/image/primitives-pt1-v3.png)

- **Undefined**: 只有一个值，`undefined`
- **Null**: 只有一个值， `null`
- **Booleans**: 两个值，`true` 和 `false`
- **Numbers**: 每个浮点数都是一个值

我们还了解到一些关于 JavaScript 数字的有趣事实：

- **不是所有的数字都可以在 JavaScript 中完美表示的。** 它们的小数部分距离 `0` 越近精度越高，越远的话精度越低。
我们可以说它的小数部分是 “浮动的”。
- **从无效的数学运算（比如 `1 / 0` 或 `0 / 0`）中得到的数字是特殊的。** NaN 就是这样的一个数字。它们可能因为编码错误而出现。
- **`typeof(NaN)` 是一个数字因为 NaN 是一个数字类型的值。** 之所以称为“非数字”，是因为它代表了“无效”数字的 _概念_。

在第二部分，我们将继续我们的观光之旅。我们将研究 BigInts、strings、objects 和 Functions -- 并且尝试计算它们。

## 测验

这个模块也有测验供你练习！

[Click here to solidify this mental model with a few short exercises.](https://eggheadio.typeform.com/to/C3Ajk4?email=yukiniro@hotmail.com&ck_subscriber_id=745643025)

**不要跳过它们**

尽管您可能熟悉不同类型的价值观，但这些练习将帮助您巩固我们正在构建的心智模型。 在我们进入更复杂的主题之前，我们需要这个基础。

Cheers,
Dan